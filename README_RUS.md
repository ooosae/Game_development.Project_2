# Game Design

Ознакомление с основными принцами создания и проектирования игр, а также рассмотрение различных подходов к созданию ИИ.


## Contents

1. [Chapter I](#chapter-i) \
   1.1. [Introduction](#introduction)
2. [Chapter II](#chapter-ii) \
   2.1. [Дизайн-документ игры](#дизайн-документ-игры) \
   2.2. [Архитектура на MonoBehaviour](#архитектура-на-monobehaviour) \
   2.3. [ScriptableObject](#scriptableobject) \
   2.4. [MV* паттерны](#mv-паттерны) \
   2.5. [Реактивное программирование](#реактивное-программирование) \
   2.6. [Создание игрового ИИ](#создание-игрового-ии)
3. [Chapter III](#chapter-iii) \
   3.1. [Part 1. Game Design Document](#part-1-game-design-document) \
   3.2. [Part 2. Refactor](#part-2-refactor) \
   3.3. [Part 3. AI](#part-3-ai)


## Chapter I

## Introduction

В данном проекте тебе предстоит изучить структуру дизайн-документа игры, ознакомиться с некоторыми архитектурными паттернами и подходами к созданию ИИ, узнать про реактивное программирование и трехслойную архитектуру в рамках игровой разработки.

В конце тебе будет необходимо написать дизайн-документ своего проекта, провести рефакторинг кода игры, а также интегрировать в нее ИИ.


## Chapter II

### Дизайн-документ игры

**Game Design Document (GDD)** - это детальное описание всех ключевых аспектов игры.

Благодаря геймдизайн-документу каждый член команды видит “картину целиком”, что значительно облегчает понимание текущих задач на проекте. Кроме этого, GDD является отличным решением для фиксации изменений и нововведений в проекте, которые возникают по ходу разработки. Важно понимать, что GDD изменяется и эволюционирует на протяжении всего проекта.

**Основные пункты дизайн-документа:**

- **Оглавление**
- **Вступление**. Краткое описание проекта: название, платформа, используемые технологии и целевая аудитория игры
- **Геймплей**. Подробное описание кор-геймплея. Необходимо выделить, какая часть игры является базовой для определения опыта игрока.
- **Внутриигровой UI или HUD**. Heads-Up Display - часть визуального интерфейса, отображающаяся на переднем плане в игре; то, что игрок видит во время геймплея
- **Мокап интерфейсов и главного меню**. Схематичный набросок в графическом редакторе всех окон/интерфейсов/экранов игры. К каждому из них прилагается краткое описание
- **Фичи**. Ключевые и дополнительные механики: обучение, инвентарь, диалоги, прокачка и другие. Обязательно создание мокапа для каждой фичи (схематичные наброски всего, что связано с этой фичей)
- **Функциональные разделы**. Могут отличаться для разных жанров игр. Например, балансировка игры, панель администратора, монетизация, форматы продвижения, сбор статистики и т. п.

### Архитектура на MonoBehaviour

Самый очевидный способ проектирования игры - использование объектно-ориентированного программирования. Архитектура для Unity игр в этом случае становится похожей на паттерн EC (Entity Component): существуют сущности с набором компонентов (в виде **MonoBehaviour** скриптов), содержащие данные и методы по работе с этими данными, выстроенные в определенную иерархию.

```csharp
public class Gun : MonoBehaviour
{
    [SerializeField]
    private int ammo;

    public void Shoot()
    {
        ammo--;
        // ...
    }
}
```

```csharp
public class Player : MonoBehaviour
{
    [SerializeField]
    private Gun gun;

    private void Update()
    {
        if (Input.GetMouseButtonDown(0))
            gun.Shoot();
    }
}
```

Одна из основных проблем **MonoBehaviour** - невозможность вызова конструктора. Если обычной программе на языке C# основной способ инъекции зависимостей - передача их через конструктор в качестве параметров, то в **Unity** этот способ не сработает.

Вместо этого принято использовать другие подходы к разрешению зависимостей, напирмер:

- Методы поиска компонентов по их типу - **GetComponent** (поиск компонента внутри текущего **GameObject**), **FindObjectOfType** (поиск компонента на всей сцене) и т. п. Стоит отметить, что эти методы ресурсозатратные (особенно **Find**-методы), поэтому особенно не рекомендуется их использовать внутри **Update** и **FixedUpdate**.
- Сериализованные поля - поля, помеченные атрибутом `[SerializeField]`, позволяющие перетаскивать зависимости через инспектор (см. пример с классами `Player` и `Gun`).

Тут же возникает еще одна серьезная проблема - неявная последовательность вызова методов инициализации. Рассмотрим все тот же пример с игроком и пистолетом:

```csharp
public class Gun : MonoBehaviour
{
    public string Name { get; private set; }

    private void Awake()
    {
        Name = "Desert Eagle";
    }
}
```

```csharp
public class Player : MonoBehaviour
{
    [SerializeField]
    private Gun gun;

    private void Awake()
    {
        Debug.Log("My gun is " + gun.Name); // может быть null (а может и не быть)
    }
}
```

В данном примере игрок выполняет действия, связанные с пистолетом в методе **Awake**. Проблема заключается в том, что пистолет также выполняет инициализацию в собственном методе **Awake**. Получается, к моменту выполнения метода **Awake** игрока пистолет может не успеть инициализироваться - мы не можем гарантировать, что **Awake** пистолета вызовется до **Awake** игрока.

Поэтому проектирование игры полностью на **MonoBehaviour**, несмотря на то что является самым очевидным способом, может привести ко многим проблемам:

1. Как уже было сказано ранее, инъекция зависимостей в **MonoBehaviour** является непростой задачей, во многом из-за отсутствия конструкторов.
2. Используя компоненты юнити в игровой логике, мы становимся привязаны к **UnityEngine** - лишняя зависимость, которая также усложняет задачу разделения архитектуры на слои и  выделения модели.
3. Классическая проблема ООП подхода: горизонтальные связи между сущностями. Предположим, есть `Player` и `Enemy`, который может получать урон от игрока. Возникает вопрос: какой из этих классов должен знать о существовании другого и быть ответственным за нанесение урона?

### ScriptableObject

**ScriptableObject (SO)** - это специальный класс **Unity**, экземпляры которого позволяют хранить данные независимо от экземпляров скриптов.

**ScriptableObject**, в отличие от **GameObject**, существует не в контексте определенной сцены, а в контексте всего проекта. С помощью **SO** можно удобно передавать данные как между **MonoBehaviour** скриптами, так и между разными сценами.

Пример **ScriptableObject**:

```csharp
[CreateAssetMenu]
public class SwordConfig : ScriptableObject
{
    public string Name;
    public Color Color;
    public float Damage;
}
```

Чтобы создать экземпляр **SO** нужно нажать на его название в меню **Create**.

![SO_Creation](misc/images/SO_Creation.png)

Созданный экземпляр можно настроить через инспектор.

![SO_Config](misc/images/SO_Config.png)

Теперь можно создать **MonoBehaviour** скрипт меча, который считывает параметры из **ScriptableObject**:

```csharp
public class Sword : MonoBehaviour
{
    [SerializeField]
    private SwordConfig swordConfig;

    private void Start()
    {
        Debug.Log("Name: " + swordConfig.Name);
        Debug.Log("Color: " + swordConfig.Color);
        Debug.Log("Damage: " + swordConfig.Damage);
    }
}
```

Ссылки на **SO**, как и ссылки на **GameObject**, добавляются в инспекторе через сериализованные поля.

![SO_Link](misc/images/SO_Link.png)

**Архитектура на ScriptableObject**

**ScriptableObject** не способны полностью заменить **MonoBehaviour** при создании игры, но паттерны, использующие **SO**, могут существенно облегчить процесс разработки небольших проектов.

**Первый паттерн - EventChannel**. SO в этом случае выступает в качестве некого канала, который связывает две независимые части системы, позволяющий передавать сообщения или события между этими частями.

Так выглядит простейшая реализация **EventChannel**:

```csharp
[CreateAssetMenu]
public class EventChannel : ScriptableObject
{
    public event Action Event;

    public void RaiseEvent()
        => Event?.Invoke();
}
```

Допустим, в нашей игре есть скрипт **Game** и кнопка выхода. При нажатии на кнопку класс **Game** должен выполнять логику по выходу из игры. Для этого можно добавить ссылку на один **EventChannel** классам **Game** и **ExitButton** - скрипт кнопки будет вызывать событие, а скрипт игры будет его принимать:

```csharp
public class ExitButton : MonoBehaviour
{
    [SerializeField]
    private EventChannel exitEventChannel;

    [SerializeField]
    private Button button;

    private void Start()
        => button.onClick.AddListener(SendExitEvent);

    private void OnDestroy()
        => button.onClick.RemoveListener(SendExitEvent);

    private void SendExitEvent()
        => exitEventChannel.RaiseEvent();
}
```

```csharp
public class Game : MonoBehaviour
{
    [SerializeField]
    private EventChannel exitEventChannel;

    private void Start()
        => exitEventChannel.Event += OnExitEvent;

    private void OnDestroy()
        => exitEventChannel.Event -= OnExitEvent;

    private void OnExitEvent()
        => Application.Quit();
}
```

Этот паттерн имеет очевидные достоинства: простота использования и обеспечение низкой связанности между классами (**Game** и **ExitButton** ничего не знают друг о друге).

Серьезный недостаток - отсутствие поддержки со стороны IDE. В отличие он обычных C# событий, мы не сможем отследить все места в коде, где используется тот или иной **EventChannel**. Кроме этого, повсеместное использование EventChannel может привести к тому, что код станет более запутанным, так как в теории любой скрипт может отправлять события и любой скрипт может их принимать, но эти события нельзя отследить в IDE.

Идея **второго паттерна** заключается в создании **ScriptableObject**, содержащего поле (свойство) и предоставляющего глобальный доступ к этому полю (свойству).

```csharp
[CreateAssetMenu]
public class FloatVariable : ScriptableObject
{
    public float Value { get; set; }
}
```

Предположим, у нас есть игрок, имеющий очки здоровья, и элемент UI, отображающий очки здоровья игрока. Примерно так будет выглядеть реализация паттерна:

```csharp
public class Player : MonoBehaviour
{
    [SerializeField]
    private FloatVariable healthVariable;

    private void Start()
    {
        healthVariable.Value = 100f;
    }
}
```

```csharp
public class HealthDisplay : MonoBehaviour
{
    [SerializeField]
    private FloatVariable healthVariable;

    [SerializeField]
    private TMP_Text healthText;

    private void Update()
    {
        healthText.text = "Player HP: " + healthVariable.Value;
    }
}
```

**FloatVariable**, по сути, глобальная переменная со всеми вытекающими проблемами - в этом заключается серьезный недостаток этого паттерна.

### MV* паттерны

**MV*** паттерны обычно применяются для проектирования приложений с графическим интерфейсом, но их также можно использовать при разработке игр.

Идея **MV*** паттернов состоит в разделении архитектуры приложения на три слоя:

- **Model** (модель) - данные и бизнес-логика;
- **View** (представление) - слой, с которым непосредственно взаимодействует пользователь;
- Связующее звено между моделью и представлением: **Controller**, **Presenter**, **ViewModel** для **MVC**, **MVP**, **MVVM** паттернов соответственно.

![MV_Patterns](misc/images/MV_Patterns.png)

Применительно к **Unity** паттерны будут выглядеть примерно так:

- **Model** - как правило, чистый C# класс, содержащий данные и бизнес-логику;
- **View** - **MonoBehaviour** скрипт, взаимодействующий с элементами UI, не содержащий бизнес-логики;
- **Controller**/**Presenter**/**ViewModel** - связующее звено между **View** и **Model**. Может быть как **MonoBehaviour** скриптом, так и чистым C# классом.

Паттерны MV* нужны для того, чтобы разделить логические части приложения и иметь возможность создавать их отдельно друг от друга. То есть писать независимые блоки кода, которые можно менять как угодно, не затрагивая другие. Более того, при правильном разделении один из слоев можно будет без особых проблем заменить на другой (например, добавить новый **View**, оставив старый **Model**, или перенести часть бизнес-логики на сервер, не затрагивая логику **View**).

Однако, несмотря на то, что MV* паттерны позволяют разделить бизнес-логику и отображение и частично избежать зависимостей от `UnityEngine`, они все еще не решают в полной мере проблемы горизонтальных связей между сущностями.

### Реактивное программирование

**Реактивное программирование** - это подход к программированию, строящийся на взаимодействии с потоками данных.

**Поток** - своеобразный таймлайн, где ты можешь отслеживать состояние твоего объекта или его параметров и подписываться на его изменение, оперируя данными.

К примеру, у нас есть игрок, который может получать урон от противника, и UI, выводящий текущее здоровье игрока. В реактивном подходе мы создаем поток данных (к примеру здоровье игрока) у которого будет свой таймлайн, во время которого значения здоровья будет меняться и вызывать событие об этом, а все подписчики - получать новое событие.

Для реактивного программирования в **Unity** существует библиотека **UniRx**. Так выглядит пример с игроком и UI:

```csharp
public class Player : MonoBehaviour
{
    public ReactiveProperty<float> Health = new ReactiveProperty<float>(100f);

    public void ApplyDamage(float damage)
        => Health -= damage;
}
```

```csharp
public class UI : MonoBehaviour
{
    [SerializeField]
    private Player player;

    [SerializeField]
    private Text healthText;

    private void Start()
    {
        player.Health.SubscribeToText(healthText);
    }
}
```

**Преимущества реактивного программирования:**

- Уменьшается связность кода;
- Высокий контроль над данными и событиями;
- Сочетается с ООП подходом.

К недостаткам реактивного программирования можно отнести необходимость использования дополнительных библиотек для работы с потоками, сложность отслеживания этих потоков в процессе разработки, отладки и тестирования, а также сложность в понимании для новичков. 

### Создание игрового ИИ

Самый простой способ создания базового игрового ИИ - использование операторов if-else для описания логики поведения:

```csharp
if (IsEnemyClose())
{
    if (HasEnoughHealth())
        AttackEnemy();
    else
        RunAway();
}
else
{
    Walk();
}
```

Этот подход обычно не используется, так как при увеличении числа возможных состояний и вариантов поведений код становится очень трудно поддерживать.

****Finite State Machine (FSM) и Hierarchical Finite State Machine (HFSM)****

****Finite State Machine**** - представляет собой направленный граф, в котором прописаны все возможные состояния системы и условия (события) для перехода между ними.

![FSM](misc/images/FSM.png)

К примеру, бот находится в состоянии **Walk (S)**. Он будет находиться в этом состоянии до тех пор, пока не произойдет событие (или выполнится условие) **EnemyClose (E)**, после чего активное состояние перейдет в другое состояние - **AttackEnemy (S)**.

Для уменьшения сложности мы также можем разделить определенные модели поведения на подсостояния, используя ****Hierarchical Finite State Machine****.

![HFSM](misc/images/HFSM.png)

Возможность перехода из любого состояния в любое другое состояние путем задания условий (событий) упрощает проектирование поведения ИИ. Но по мере роста размера и сложности **FSM** и **HFSM** становятся трудно поддерживаемыми.

****Behavior Tree (BT)****

**Behavior Tree** представляют собой деревья, предназначенные для описания сложного поведения и принятия решения о выборе поведения. На каждом такте рассчитывается все дерево, и если выбрано другое поведение (действие), отличное от текущего, то состояние изменится, в противном случае текущее поведение продолжит выполняться.

![BT](misc/images/BT.png)

**На схеме представлены три вида узлов:**

1. Синие: **sector nodes**, родительские узлы которые выполняют каждый из дочерних узлов по порядку.
2. Зеленые: **conditional** и **decoration nodes**, контролируют процесс выполнения узлов.
3. Красные: **action nodes**, действия, которые должны быть выполнены.

Во многих случаях **BT** обеспечивает основу для разработки более понятных и легко читаемых ИИ, чем иерархическая **FSM**. Основной недостаток заключается в том, что для очень больших **BT** затраты на оценку всего дерева могут оказаться крайне высокими.

****Goal Oriented Action Planning (GOAP) или Utility AI****

**GOAP** работает путем определения вариантов поведения, доступных ИИ, и выбора наилучшего варианта в конкретной ситуации.

В **GOAP** ты предоставляешь планировщику список действий, которые ИИ может выполнять, текущее состояние мира и желаемое состояние мира (целевое состояние). Затем **GOAP** попытается найти серию действий, которые приведут ИИ к целевому состоянию.

Схожим образом работает **Utility AI**. Его также принято называть методом “оценки полезности”. Каждому возможному действию присваивается свой вес, с помощью которого ИИ выбирает наиболее приоритетное действие и выполняет его.

**GOAP** и **Utility AI** хорошо себя показывают в ситуациях, где нет однозначно правильной или неправильной последовательности действий. В этом также кроется недостаток данных подходов - нельзя предсказать поведение ИИ в конкретный момент времени.


## Chapter III

### Part 1. Game Design Document

Требуется написать дизайн-документ для разработанной тобой игры из проекта Meeting Unity.

- Документ быть составлен в формате **.md** и находиться внутри репозитория.
- К главам про **UI**, **мокап интерфейса** и **фичи** должны быть приложены соответствующие изображения. Они могут быть как скриншотами из игры, так и созданными с нуля схематичными набросками. Каждый элемент списка должен быть подписан. При необходимости можно добавить пояснения.
- В документе должен быть как минимум один **функциональный раздел** (например, про монетизацию или продвижение).

### Part 2. Refactor

Требуется провести рефакторинг кода твоей игры из проекта Meeting Unity с использованием изученных подходов.

- Необходимо полностью избавиться от так называемых **Find**-методов (**FindGameObjectsWithTag, FindObjectOfType** и т. д.)
- Внутри **Update** и **FixedUpdate** не должны вызываться методы, выполняющие поиск компонентов (**GetComponent**, **GetComponentInChildren** и т. д.)
- В твоих классах не должно быть публичных полей (публичные свойства разрешаются, но только с модификаторами `get;` или `get; private set;`).
- Старайся избегать статических методов, свойств, событий, классов; также избегай использования паттерна **Singleton**.
- Необходимо добавить в проект как минимум один **ScriptableObject** (его можно использовать, например, для хранения конфигурации или в качестве рассмотренного ранее **EventChannel**).
- Перестрой архитектуру твоего проекта с использованием одного из **MV*** паттернов. Пример создания лидерборда на **MVP:** UI (в роли **View)** запрашивает нужные данные у **Presenter**; **Presenter** передает запрос в **Model**, полученные из **Model** данные передает обратно на **View**; а сам **Model** содержит бизнес-логику для сохранения и получения списка лидеров. Для удобства последующей проверки следует добавить **Model**, **View** и т. д. к именам соответствующих классов (например, **LeaderStoragePresenter**, **ScoreView** и т. п.)

### Part 3. AI

Необходимо интегрировать ИИ в твою игру. Для реализации ИИ рекомендуется использовать **FSM**, но можно также выбрать один из следующих способов: **HFSM**, **BT**, **GOAP**, **Utility AI**.

**Для тематики проекта №1 (игра в стиле Crowd City)**

- Необходимо реализовать ИИ врагов.
- Враги, как и игрок, должны собирать толпы и атаковать других врагов или игрока.
- Враг, встретившись с толпой меньшего размера, с большей вероятностью должен начать атаковать, а встретившись с толпой большего размера - убегать.

**Для тематики проекта №2 (игра в жанре endless runner)**

- Необходимо реализовать ИИ соперников.
- Соперники бегут рядом с игроком с разными скоростями, стараясь избегать препятствий (реакция ботов не должна быть идеальной).
- Игрок может сбивать соперников, перемещаясь на их полосу. За это он получает дополнительные очки.

**Для тематики проекта №3 (игра в стиле My Mini Mart)**

- Необходимо реализовать ИИ покупателей.
- Покупатели должны приходить в лавку и ждать своего заказа. Если заказ был выполнен успешно, то игрок получает валюту, иначе ничего не получает.
- Не получив свой заказ в течение определенного времени, покупатель уходит (необходимо каким-либо образом визуализировать текущий заказ и оставшееся время ожидания каждого покупателя).

💡 [Нажми тут](https://forms.yandex.ru/cloud/647071deeb614618dbf1aad9/), **чтобы поделиться с нами обратной связью на этот проект**. Это анонимно и поможет команде Продукта сделать твоё обучение лучше.
